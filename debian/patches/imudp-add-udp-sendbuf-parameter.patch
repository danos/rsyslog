commit 79032d68ca14627ad8b63d1cc3772928800c815f
Author: Rainer Gerhards <rgerhards@adiscon.com>
Date:   Tue Jul 11 15:51:11 2017 +0200

    imudp: add "udp.sendbuf" parameter
---
 plugins/imudp/imudp.c           |    2 +-
 plugins/omudpspoof/omudpspoof.c |    2 +-
 runtime/net.c                   |   34 +++++++++++++++++++++++++++++++++-
 runtime/net.h                   |    2 +-
 tools/omfwd.c                   |   16 +++++++++++-----
 5 files changed, 47 insertions(+), 9 deletions(-)

--- a/plugins/imudp/imudp.c
+++ b/plugins/imudp/imudp.c
@@ -301,7 +301,7 @@ addListner(instanceConf_t *inst)
 
 	DBGPRINTF("Trying to open syslog UDP ports at %s:%s.\n", bindName, inst->pszBindPort);
 
-	newSocks = net.create_udp_socket(bindAddr, port, 1, inst->rcvbuf, inst->ipfreebind, inst->pszBindDevice);
+	newSocks = net.create_udp_socket(bindAddr, port, 1, inst->rcvbuf, 0, inst->ipfreebind, inst->pszBindDevice);
 	if(newSocks != NULL) {
 		/* we now need to add the new sockets to the existing set */
 		/* ready to copy */
--- a/plugins/omudpspoof/omudpspoof.c
+++ b/plugins/omudpspoof/omudpspoof.c
@@ -576,7 +576,7 @@ static rsRetVal doTryResume(wrkrInstance
 	}
 	DBGPRINTF("%s found, resuming.\n", pData->host);
 	pWrkrData->f_addr = res;
-	pWrkrData->pSockArray = net.create_udp_socket((uchar*)pData->host, NULL, 0, 0, 0, NULL);
+	pWrkrData->pSockArray = net.create_udp_socket((uchar*)pData->host, NULL, 0, 0, 0, 0, NULL);
 
 finalize_it:
 	if(iRet != RS_RET_OK) {
--- a/runtime/net.c
+++ b/runtime/net.c
@@ -62,6 +62,7 @@
 #include "net.h"
 #include "dnscache.h"
 #include "prop.h"
+#include "errmsg.h"
 
 #ifdef OS_SOLARIS
 #	define	s6_addr32	_S6_un._S6_u32
@@ -1241,12 +1242,13 @@ closeUDPListenSockets(int *pSockArr)
  * param rcvbuf indicates desired rcvbuf size; 0 means OS default
  */
 static int *
-create_udp_socket(uchar *hostname, uchar *pszPort, int bIsServer, int rcvbuf, int ipfreebind, char *device)
+create_udp_socket(uchar *hostname, uchar *pszPort, int bIsServer, int rcvbuf, const int sndbuf, int ipfreebind, char *device)
 {
         struct addrinfo hints, *res, *r;
         int error, maxs, *s, *socks, on = 1;
 	int sockflags;
 	int actrcvbuf;
+	int actsndbuf;
 	socklen_t optlen;
 	char errStr[1024];
 
@@ -1377,6 +1379,36 @@ create_udp_socket(uchar *hostname, uchar
 			continue;
 		}
 
+		if(sndbuf != 0) {
+#			if defined(SO_SNDBUFFORCE)
+			if(setsockopt(*s, SOL_SOCKET, SO_SNDBUFFORCE, &sndbuf, sizeof(sndbuf)) < 0)
+#			endif
+			{
+				/* if we fail, try to do it the regular way. Experiments show that at
+				 * least some platforms do not return an error here, but silently set
+				 * it to the max permitted value. So we do our error check a bit
+				 * differently by querying the size below.
+				 */
+				setsockopt(*s, SOL_SOCKET, SO_SNDBUF, &sndbuf, sizeof(sndbuf));
+			}
+		}
+
+		if(Debug || sndbuf != 0) {
+			optlen = sizeof(actsndbuf);
+			if(getsockopt(*s, SOL_SOCKET, SO_SNDBUF, &actsndbuf, &optlen) == 0) {
+				dbgprintf("socket %d, actual os socket sndbuf size %d\n", *s, actsndbuf);
+				errmsg.LogError(0, RS_RET_ERR,"socket %d, actual os socket sndbuf size %d", *s, actsndbuf);
+				if(sndbuf != 0 && actsndbuf/2 != sndbuf) {
+					errmsg.LogError(errno, NO_ERRCODE,
+						"cannot set os socket sndbuf size %d for socket %d, value now is %d",
+						sndbuf, *s, actsndbuf/2);
+				}
+			} else {
+				dbgprintf("could not obtain os socket rcvbuf size for socket %d: %s\n",
+					*s, rs_strerror_r(errno, errStr, sizeof(errStr)));
+			}
+		}
+
 		if(rcvbuf != 0) {
 #			if defined(SO_RCVBUFFORCE)
 			if(setsockopt(*s, SOL_SOCKET, SO_RCVBUFFORCE, &rcvbuf, sizeof(rcvbuf)) < 0)
--- a/runtime/net.h
+++ b/runtime/net.h
@@ -148,7 +148,7 @@ BEGINinterface(net) /* name must also be
 	void (*PrintAllowedSenders)(int iListToPrint);
 	void (*clearAllowedSenders)(uchar*);
 	void (*debugListenInfo)(int fd, char *type);
-	int *(*create_udp_socket)(uchar *hostname, uchar *LogPort, int bIsServer, int rcvbuf, int ipfreebind, char *device);
+	int *(*create_udp_socket)(uchar *hostname, uchar *LogPort, int bIsServer, int rcvbuf, int sndbuf, int ipfreebind, char *device);
 	void (*closeUDPListenSockets)(int *finet);
 	int (*isAllowedSender)(uchar *pszType, struct sockaddr *pFrom, const char *pszFromHost); /* deprecated! */
 	rsRetVal (*getLocalHostname)(uchar**);
--- a/tools/omfwd.c
+++ b/tools/omfwd.c
@@ -97,6 +97,7 @@ typedef struct _instanceData {
 	/* following fields for UDP-based delivery */
 	int bSendToAll;
 	int iUDPSendDelay;
+	int UDPSendBuf;
 	/* following fields for TCP-based delivery */
 	TCPFRAMINGMODE tcp_framing;
 	int bResendLastOnRecon; /* should the last message be re-sent on a successful reconnect? */
@@ -176,6 +177,7 @@ static struct cnfparamdescr actpdescr[]
 	{ "resendlastmsgonreconnect", eCmdHdlrBinary, 0 },
 	{ "udp.sendtoall", eCmdHdlrBinary, 0 },
 	{ "udp.senddelay", eCmdHdlrInt, 0 },
+	{ "udp.sendbuf", eCmdHdlrSize, 0 },
 	{ "template", eCmdHdlrGetWord, 0 }
 };
 static struct cnfparamblk actpblk =
@@ -416,7 +418,7 @@ static rsRetVal UDPSend(wrkrInstanceData
 	DEFiRet;
 	struct addrinfo *r;
 	int i;
-	unsigned lsent = 0;
+	ssize_t lsent = 0;
 	sbool bSendSuccess;
 	sbool reInit = RSFALSE;
 	int lasterrno = ENOENT;
@@ -443,8 +445,8 @@ static rsRetVal UDPSend(wrkrInstanceData
 		bSendSuccess = RSFALSE;
 		for (r = pWrkrData->f_addr; r; r = r->ai_next) {
 			for (i = 0; i < *pWrkrData->pSockArray; i++) {
-			       lsent = sendto(pWrkrData->pSockArray[i+1], msg, len, 0, r->ai_addr, r->ai_addrlen);
-				if (lsent == len) {
+				lsent = sendto(pWrkrData->pSockArray[i+1], msg, len, 0, r->ai_addr, r->ai_addrlen);
+				if (lsent == (ssize_t) len) {
 					bSendSuccess = RSTRUE;
 					break;
 				} else {
@@ -455,7 +457,7 @@ static rsRetVal UDPSend(wrkrInstanceData
 						rs_strerror_r(lasterrno, errStr, sizeof(errStr)));
 				}
 			}
-			if (lsent == len && !pWrkrData->pData->bSendToAll)
+			if (lsent == (ssize_t) len && !pWrkrData->pData->bSendToAll)
 			       break;
 		}
 
@@ -769,7 +771,8 @@ static rsRetVal doTryResume(wrkrInstance
 		dbgprintf("%s found, resuming.\n", pData->target);
 		pWrkrData->f_addr = res;
 		if(pWrkrData->pSockArray == NULL) {
-			pWrkrData->pSockArray = net.create_udp_socket((uchar*)pData->target, NULL, 0, 0, 0, pData->device);
+			pWrkrData->pSockArray = net.create_udp_socket((uchar*)pData->target,
+				NULL, 0, 0, pData->UDPSendBuf, 0, pData->device);
 		}
 		if(pWrkrData->pSockArray != NULL) {
 			pWrkrData->bIsConnected = 1;
@@ -961,6 +964,7 @@ setInstParamDefaults(instanceData *pData
 	pData->bResendLastOnRecon = 0; 
 	pData->bSendToAll = -1;  /* unspecified */
 	pData->iUDPSendDelay = 0;
+	pData->UDPSendBuf = 0;
 	pData->pPermPeers = NULL;
 	pData->compressionLevel = 9;
 	pData->strmCompFlushOnTxEnd = 1;
@@ -1097,6 +1101,8 @@ CODESTARTnewActInst
 			pData->bSendToAll = (int) pvals[i].val.d.n;
 		} else if(!strcmp(actpblk.descr[i].name, "udp.senddelay")) {
 			pData->iUDPSendDelay = (int) pvals[i].val.d.n;
+		} else if(!strcmp(actpblk.descr[i].name, "udp.sendbuf")) {
+			pData->UDPSendBuf = (int) pvals[i].val.d.n;
 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
 			pData->tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
 		} else if(!strcmp(actpblk.descr[i].name, "compression.stream.flushontxend")) {
