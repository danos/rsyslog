omfwd: add support for bind-to-address for UDP

To allow the same source address to be used regardless of the egress
interface taken, an address option is added so as to bind the datagram
socket to. Similarly to imudp, it is necessary to add an ipfreebind
option which is set by default, so as to avoid an excess of errors at
startup before the network interface has come up. This enhancement
allows a usecase on networking devices, by which a source interface
that is typically a loopback is specified, on which an address to bind
to is configured. This is so that the same source address is used for
all packets from rsyslog. Support for the TCP case could be added later.

Signed-off-by: Mike Manning <mmanning@att.com>
---
 tools/omfwd.c |   41 ++++++++++++++++++++++++++++++++++++++---
 1 file changed, 38 insertions(+), 3 deletions(-)

--- a/tools/omfwd.c
+++ b/tools/omfwd.c
@@ -83,6 +83,7 @@ typedef struct _instanceData {
 	permittedPeers_t *pPermPeers;
 	int iStrmDrvrMode;
 	char	*target;
+	char	*address;
 	char	*device;
 	int compressionLevel;	/* 0 - no compression, else level for zlib */
 	char *port;
@@ -94,6 +95,10 @@ typedef struct _instanceData {
 	int iKeepAliveIntvl;
 	int iKeepAliveProbes;
 	int iKeepAliveTime;
+	/*  0 means:  IP_FREEBIND is disabled
+	1 means:  IP_FREEBIND enabled + warning disabled
+	1+ means: IP+FREEBIND enabled + warning enabled */
+	int ipfreebind;
 
 #	define	FORW_UDP 0
 #	define	FORW_TCP 1
@@ -160,6 +165,7 @@ static struct cnfparamblk modpblk =
 /* action (instance) parameters */
 static struct cnfparamdescr actpdescr[] = {
 	{ "target", eCmdHdlrGetWord, 0 },
+	{ "address", eCmdHdlrGetWord, 0 },
 	{ "device", eCmdHdlrGetWord, 0 },
 	{ "port", eCmdHdlrGetWord, 0 },
 	{ "protocol", eCmdHdlrGetWord, 0 },
@@ -168,6 +174,7 @@ static struct cnfparamdescr actpdescr[]
 	{ "ziplevel", eCmdHdlrInt, 0 },
 	{ "compression.mode", eCmdHdlrGetWord, 0 },
 	{ "compression.stream.flushontxend", eCmdHdlrBinary, 0 },
+	{ "ipfreebind", eCmdHdlrInt, 0 },
 	{ "maxerrormessages", eCmdHdlrInt, 0 },
 	{ "rebindinterval", eCmdHdlrInt, 0 },
 	{ "keepalive", eCmdHdlrBinary, 0 },
@@ -391,6 +398,7 @@ CODESTARTfreeInstance
 	free(pData->port);
 	free(pData->networkNamespace);
 	free(pData->target);
+	free(pData->address);
 	free(pData->device);
 	net.DestructPermittedPeers(&pData->pPermPeers);
 ENDfreeInstance
@@ -834,9 +842,11 @@ finalize_it:
 static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData)
 {
 	int iErr;
-	struct addrinfo *res;
+	struct addrinfo *res, *addr;
 	struct addrinfo hints;
 	instanceData *pData;
+	int bBindRequired = 0;
+	char *address;
 	DEFiRet;
 
 	if(pWrkrData->bIsConnected)
@@ -855,12 +865,26 @@ static rsRetVal doTryResume(wrkrInstance
 				  pData->target, pData->port, iErr, gai_strerror(iErr));
 			ABORT_FINALIZE(RS_RET_SUSPENDED);
 		}
+		address = pData->target;
+		if(pData->address) {
+			/* The AF of the bind addr must match that of target */
+			hints.ai_family = res->ai_family;
+			hints.ai_flags |= AI_PASSIVE;
+			if((iErr = getaddrinfo(pData->address, pData->port, &hints, &addr)) != 0) {
+				errmsg.LogError(0, RS_RET_SUSPENDED,
+						"omfwd: cannot use bind address '%s' for host '%s': %s",
+						pData->address, pData->target, gai_strerror(iErr));
+				ABORT_FINALIZE(RS_RET_SUSPENDED);
+			}
+			bBindRequired = 1;
+			address = pData->address;
+		}
 		dbgprintf("%s found, resuming.\n", pData->target);
 		pWrkrData->f_addr = res;
 		if(pWrkrData->pSockArray == NULL) {
 			CHKiRet(changeToNs(pData));
-			pWrkrData->pSockArray = net.create_udp_socket((uchar*)pData->target,
-				NULL, 0, 0, pData->UDPSendBuf, 0, pData->device);
+			pWrkrData->pSockArray = net.create_udp_socket((uchar*)address,
+				NULL, bBindRequired, 0, pData->UDPSendBuf, pData->ipfreebind, pData->device);
 			CHKiRet(returnToOriginalNs(pData));
 		}
 		if(pWrkrData->pSockArray != NULL) {
@@ -1063,6 +1087,7 @@ setInstParamDefaults(instanceData *pData
 	pData->strmCompFlushOnTxEnd = 1;
 	pData->compressionMode = COMPRESS_NEVER;
 	pData->errsToReport = 5;
+	pData->ipfreebind = IPFREEBIND_ENABLED_WITH_LOG;
 }
 
 BEGINnewActInst
@@ -1095,6 +1120,8 @@ CODESTARTnewActInst
 			continue;
 		if(!strcmp(actpblk.descr[i].name, "target")) {
 			pData->target = es_str2cstr(pvals[i].val.d.estr, NULL);
+		} else if(!strcmp(actpblk.descr[i].name, "address")) {
+			pData->address = es_str2cstr(pvals[i].val.d.estr, NULL);
 		} else if(!strcmp(actpblk.descr[i].name, "device")) {
 			pData->device = es_str2cstr(pvals[i].val.d.estr, NULL);
 		} else if(!strcmp(actpblk.descr[i].name, "port")) {
@@ -1217,6 +1244,8 @@ CODESTARTnewActInst
 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
 			}
 			free(cstr);
+		} else if(!strcmp(actpblk.descr[i].name, "ipfreebind")) {
+			pData->ipfreebind = (int) pvals[i].val.d.n;
 		} else {
 			errmsg.LogError(0, RS_RET_INTERNAL_ERROR,
 				"omfwd: program error, non-handled parameter '%s'\n",
@@ -1247,6 +1276,12 @@ CODESTARTnewActInst
 					"cannot be used with tcp transport -- ignored");
 		}
 	}
+
+	if(pData->address && (pData->protocol == FORW_TCP)) {
+		errmsg.LogError(0, RS_RET_PARAM_ERROR,
+				"omfwd: parameter \"address\" not supported for tcp -- ignored");
+	}
+
 CODE_STD_FINALIZERnewActInst
 	cnfparamvalsDestruct(pvals, &actpblk);
 ENDnewActInst
