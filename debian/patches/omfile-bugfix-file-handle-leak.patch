From: Rainer Gerhards <rgerhards@adiscon.com>
Date: Tue, 22 Oct 2019 13:17:38 +0200
Subject: omfile bugfix: file handle leak

The stream class does not close re-opened file descriptors.
This lead to leaking file handles and ultimately to the inability
to open any files/sockets/etc as rsyslog ran out of handles.

The bug was depending on timing. This involed different OS
thread scheduler timing as well as workload. The bug was more
common under the following conditions:

- async writing of files
- dynafiles
- not committing file data at end of transaction

However it could be triggered under other conditions as well.

The refactoring done in 8.1908 increased the likelihood of
experienceing this bug. But it was not a real regression, the new
code was valid, but changed the timing so that the race was more
likely.

Thanks to Michael Biebl for reporting this bug and helping to
analyze it.

closes https://github.com/rsyslog/rsyslog/issues/3885
---
 runtime/stream.c | 34 ++++++++++++++++++++--------------
 1 file changed, 20 insertions(+), 14 deletions(-)

diff --git a/runtime/stream.c b/runtime/stream.c
index 11e580d..ac332df 100644
--- a/runtime/stream.c
+++ b/runtime/stream.c
@@ -448,6 +448,19 @@ strmWaitAsyncWriterDone(strm_t *pThis)
 	}
 }
 
+/* stop the writer thread (we MUST be runnnig asynchronously when this method
+ * is called!). Note that the mutex must be locked! -- rgerhards, 2009-07-06
+ */
+static void
+stopWriter(strm_t *const pThis)
+{
+	pThis->bStopWriter = 1;
+	pthread_cond_signal(&pThis->notEmpty);
+	d_pthread_mutex_unlock(&pThis->mut);
+	pthread_join(pThis->writerThreadID, NULL);
+}
+
+
 
 /* close a strm file
  * Note that the bDeleteOnClose flag is honored. If it is set, the file will be
@@ -474,6 +487,7 @@ static rsRetVal strmCloseFile(strm_t *pThis)
 		if(pThis->iZipLevel) {
 			doZipFinish(pThis);
 		}
+		stopWriter(pThis);
 	}
 
 	/* if we have a signature provider, we must make sure that the crypto
@@ -492,6 +506,8 @@ static rsRetVal strmCloseFile(strm_t *pThis)
 	 * against this. -- rgerhards, 2010-03-19
 	 */
 	if(pThis->fd != -1) {
+		DBGOPRINT((obj_t*) pThis, "file %d(%s) closing\n",
+			pThis->fd, getFileDebugName(pThis));
 		currOffs = lseek64(pThis->fd, 0, SEEK_CUR);
 		close(pThis->fd);
 		pThis->fd = -1;
@@ -1272,19 +1288,6 @@ finalize_it:
 }
 
 
-/* stop the writer thread (we MUST be runnnig asynchronously when this method
- * is called!). Note that the mutex must be locked! -- rgerhards, 2009-07-06
- */
-static void
-stopWriter(strm_t *pThis)
-{
-	pThis->bStopWriter = 1;
-	pthread_cond_signal(&pThis->notEmpty);
-	d_pthread_mutex_unlock(&pThis->mut);
-	pthread_join(pThis->writerThreadID, NULL);
-}
-
-
 /* destructor for the strm object */
 BEGINobjDestruct(strm) /* be sure to specify the object type also in END and CODESTART macros! */
 	int i;
@@ -1300,7 +1303,6 @@ CODESTARTobjDestruct(strm)
 	strmCloseFile(pThis);
 
 	if(pThis->bAsyncWrite) {
-		stopWriter(pThis);
 		pthread_mutex_destroy(&pThis->mut);
 		pthread_cond_destroy(&pThis->notFull);
 		pthread_cond_destroy(&pThis->notEmpty);
@@ -1659,6 +1661,8 @@ asyncWriterThread(void *pPtr)
 	/* Not reached */
 
 finalize_it:
+	DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread terminated\n",
+		pThis->fd, getFileDebugName(pThis));
 	return NULL; /* to keep pthreads happy */
 }
 
@@ -1890,6 +1894,8 @@ strmFlush(strm_t *pThis)
 
 	assert(pThis != NULL);
 
+	DBGOPRINT((obj_t*) pThis, "file %d strmFlush\n", pThis->fd);
+
 	if(pThis->bAsyncWrite)
 		d_pthread_mutex_lock(&pThis->mut);
 	CHKiRet(strmFlushInternal(pThis, 1));
